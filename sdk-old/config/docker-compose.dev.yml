version: "3.8"

services:
  authentication:
    container_name: "authentication"
    build:
      context: ..
      dockerfile: config/Dockerfile.dev
    image: "authentication:${APP_VERSION}"
    ports:
      - "${WEB_SERVER_PORT}:${WEB_SERVER_PORT}"
      - "${GRPC_SERVER_PORT}:${GRPC_SERVER_PORT}"
      - "${DELVE_PORT}:${DELVE_PORT}"
    volumes:
      - type: bind
        source: ..
        target: /app
    environment:
      - BUILDING_FILES=/app/services/authentication/cmd/main.go
      - APP_NAME=authentication
    depends_on:
      # - postgres
      - consul
      # - cassandra
      # - mysql
      - redis
      # - prometheus
      # - grafana
      # - pyroscope
      # - mongodb
      # - rabbitmq
      # - dynamodb
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication
    command: air -c ${AIR_CONFIG}

  monitoring-api:
    container_name: "monitoring-api"
    build:
      context: ..
      dockerfile: config/Dockerfile.dev
    image: "monitoring-api:${APP_VERSION}"
    ports:
      - "${WEB_SERVER_PORT}:${WEB_SERVER_PORT}"
      - "${DELVE_PORT}:${DELVE_PORT}"
    volumes:
      - type: bind
        source: ..
        target: /app
    environment:
      - BUILDING_FILES=/app/services/monitoring/main.go
      - APP_NAME=monitoring-api
      - PROMETHEUS_URL=http://prometheus:9090
    depends_on:
      - mysql
      - prometheus
      - grafana
    networks:
      - app-network
    restart: on-failure
    profiles:
      - monitoring    
    command: air -c ${AIR_CONFIG}

  greeter-server:
    container_name: "greeter-server"
    build:
      context: ..
      dockerfile: config/Dockerfile.dev  # Ruta al Dockerfile del servidor
    image: "greeter-server:${APP_VERSION}"
    ports:
      - "${GRPC_SERVER_PORT}:${GRPC_SERVER_PORT}"  # Exponer el puerto del servidor gRPC
      - "${DELVE_PORT_SERVER}:${DELVE_PORT_SERVER}"  # Puerto para debugging con Delve
    environment:
      - DELVE_PORT=${DELVE_PORT_SERVER}  # Sobrescribir el valor de DELVE_PORT para el servidor
      - GRPC_SERVER_HOST=0.0.0.0  # Escuchar en todas las interfaces
      - BUILDING_FILES=/app/services/greeter-server/cmd/main.go
      - APP_NAME=greeter-server
      - APP_ROLE=server
    networks:
      - app-network
    volumes:
      - type: bind
        source: ..
        target: /app
    restart: on-failure
    profiles:
      - greeter-server
    command: air -c ${AIR_CONFIG}  
    # command: air -c ${AIR_CONFIG_SERVER}

  greeter-client:
    container_name: "greeter-client"
    build:
      context: ..
      dockerfile: config/Dockerfile.dev # Ruta al Dockerfile del cliente
    image: "greeter-client:${APP_VERSION}"
    ports:
    - "${DELVE_PORT}:${DELVE_PORT}"
    environment:
      - BUILDING_FILES=/app/services/greeter-client/cmd/main.go
      - APP_NAME=greeter-client
      - APP_ROLE=client
    network_mode: "host"  # Usa la red del host
    volumes:
      - type: bind
        source: ..
        target: /app
    restart: on-failure
    profiles:
      - greeter-client
    command: air -c ${AIR_CONFIG}
    # command: air -c ${AIR_CONFIG_CLIENT}

  sg_auth:
    container_name: "sg_auth"
    build:
      context: ..
      dockerfile: config/Dockerfile.dev
    image: "sg_auth:${APP_VERSION}"
    env_file:
      - .env
      - .env.local
    ports:
      - "${WEB_SERVER_PORT}:${WEB_SERVER_PORT}"
      - "${GRPC_SERVER_PORT}:${GRPC_SERVER_PORT}"
      - "${DELVE_PORT}:${DELVE_PORT}"
    volumes:
      - type: bind
        source: ..
        target: /app
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - BUILDING_FILES=/app/sg/auth/cmd/main.go # /app/sg/auth/cmd/wire.go
      #  Probar BUILDING_FILES=/app/sg/auth/cmd/... 
      - APP_NAME=sg_auth
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      - AWS_REGION=${AWS_REGION}
      - AWS_ENDPOINT=http://localstack:${AWS_EDGE_PORT}
    depends_on:
      - localstack
    networks:
      - app-network
    restart: on-failure
    profiles:
      - sg_auth
    command: air -c ${AIR_CONFIG}

  sg_users:
    container_name: "sg_users"
    build:
      context: ..
      dockerfile: config/Dockerfile.dev
    image: "sg_users:${APP_VERSION}"
    env_file:
      - .env
      - .env.local
    ports:
      - "${WEB_SERVER_PORT}:${WEB_SERVER_PORT}"
      - "${GRPC_SERVER_PORT}:${GRPC_SERVER_PORT}"
      - "${DELVE_PORT}:${DELVE_PORT}"
    volumes:
      - type: bind
        source: ..
        target: /app
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - BUILDING_FILES=/app/sg/users/cmd/main.go
      - APP_NAME=sg_users
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      - AWS_REGION=${AWS_REGION}
      - AWS_ENDPOINT=http://localstack:${AWS_EDGE_PORT}
    depends_on:
      - localstack
      - postgres
    networks:
      - app-network
    restart: on-failure
    profiles:
      - sg_users
    command: air -c ${AIR_CONFIG}    

  sg_mailing:
    container_name: "sg_mailing"
    build:
      context: ..
      dockerfile: config/Dockerfile.dev
    image: "sg_mailing:${APP_VERSION}"
    env_file:
      - .env
      - .env.local
    ports:
      - "${WEB_SERVER_PORT}:${WEB_SERVER_PORT}"
      - "${GRPC_SERVER_PORT}:${GRPC_SERVER_PORT}"
      - "${DELVE_PORT}:${DELVE_PORT}"
    volumes:
      - type: bind
        source: ..
        target: /app
      - /var/run/docker.sock:/var/run/docker.sock
    cap_add:
      - SYS_PTRACE
    security_opt:
      - seccomp:unconfined
    environment:
      BUILDING_FILES: /app/sg/mailing/cmd/main.go
      APP_NAME: sg_mailing
      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
      AWS_REGION: ${AWS_REGION}
      AWS_ENDPOINT: http://localstack:${AWS_EDGE_PORT}
      SMTP_HOST: mailhog
      SMTP_PORT: 1025
    depends_on:
      - localstack
      - mailhog
    networks:
      - app-network
    restart: on-failure
    profiles:
      - sg_mailing
    command: air -c ${AIR_CONFIG}

  mailhog:
    image: mailhog/mailhog:v1.0.1
    container_name: "mailhog"
    ports:
      - "1025:1025"   # Puerto SMTP fijo
      - "8025:8025"   # Puerto UI web fijo
    networks:
      - app-network
    restart: on-failure
    profiles:
      - sg_mailing

  postgres:
    image: postgres:16.3
    container_name: postgres
    ports:
      - "${POSTGRES_PORT}:${POSTGRES_PORT}"
    environment:
      POSTGRES_USER: ${POSTGRES_USERNAME}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres-init:/docker-entrypoint-initdb.d # todos los scripts sql: init, migrations, etc
    networks:
      - app-network
    restart: on-failure
    profiles:
      - sg_mailing

  pgadmin:
    image: dpage/pgadmin4:8.12
    container_name: pgadmin
    ports:
      - "${PGADMIN_PORT}:${PGADMIN_TARGET_PORT}"
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
    logging:
      driver: "none"
    depends_on:
      - postgres
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication
      - sg_auth
      - sg_users

  consul:
    image: consul:1.15.4
    container_name: consul
    ports:
      - "${CONSUL_PORT}:${CONSUL_PORT}"
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  cassandra:
    image: cassandra:4.1
    container_name: cassandra
    ports:
      - "${CASSANDRA_PORT}:${CASSANDRA_PORT}"
    environment:
      - CASSANDRA_CLUSTER_NAME=${CASSANDRA_CLUSTER_NAME}
      - CASSANDRA_DC=${CASSANDRA_DC}
      - CASSANDRA_RACK=${CASSANDRA_RACK}
      - CASSANDRA_SEEDS=${CASSANDRA_HOST}
      - CASSANDRA_ENDPOINT_SNITCH=${CASSANDRA_ENDPOINT_SNITCH}
      - CASSANDRA_USERNAME=${CASSANDRA_USERNAME}
      - CASSANDRA_PASSWORD=${CASSANDRA_PASSWORD}
    volumes:
      - cassandra_data:/var/lib/cassandra
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  datastax-studio:
    image: datastax/dse-studio:6.8.32
    container_name: datastax-studio
    ports:
      - "${DS_PORT}:${DS_PORT}"
    depends_on:
      - cassandra
    environment:
      - DS_LICENSE=accept
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  redis:
    image: redis:7.0
    container_name: redis
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    command: ["redis-server", "--requirepass", "${REDIS_PASSWORD}"]
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  mysql:
    image: mysql:8.0
    container_name: mysql
    ports:
      - "${MYSQL_PORT}:${MYSQL_PORT}"
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  phpmyadmin:
    image: phpmyadmin:5.2.1-apache
    container_name: phpmyadmin
    ports:
      - "${PHPMYADMIN_PORT}:${PHPMYADMIN_TARGET_PORT}"
    environment:
      - PMA_HOST=${MYSQL_HOST}
      - PMA_USER=${MYSQL_USER}
      - PMA_PASSWORD=${MYSQL_PASSWORD}
    depends_on:
      - mysql
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  prometheus:
    image: prom/prometheus:v2.45.6
    container_name: prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "${PROMETHEUS_PORT}:${PROMETHEUS_PORT}"
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  grafana:
    image: grafana/grafana:10.2.8
    container_name: grafana
    ports:
      - "${GRAFANA_PORT}:${GRAFANA_PORT}"
    depends_on:
      - prometheus
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  pyroscope:
    image: grafana/pyroscope:weekly-f76-feefa815b
    container_name: pyroscope
    ports:
      - "${PYROSCOPE_PORT}:${PYROSCOPE_PORT}"
    volumes:
      - pyroscope_data:/var/lib/pyroscope
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  mongodb:
    image: mongo:5.0.28
    container_name: mongodb
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_INITDB_ROOT_USERNAME}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_INITDB_ROOT_PASSWORD}
    ports:
      - "${MONGO_PORT}:${MONGO_PORT}"
    volumes:
      - mongodb_data:/data/db
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  mongo-express:
    image: mongo-express:1.0.2-20-alpine3.19
    container_name: mongo-express
    environment:
      - ME_CONFIG_MONGODB_ADMINUSERNAME=${MONGO_INITDB_ROOT_USERNAME}
      - ME_CONFIG_MONGODB_ADMINPASSWORD=${MONGO_INITDB_ROOT_PASSWORD}
      - ME_CONFIG_MONGODB_SERVER=${MONGO_HOST}
      - ME_CONFIG_MONGODB_URL=${ME_CONFIG_MONGODB_URL}
    ports:
      - "${ME_PORT}:${ME_PORT}"
    depends_on:
      - mongodb
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  ngrok:
    image: ngrok/ngrok:3.13.0-alpine-91be825
    container_name: ngrok
    command: ["start", "--all", "--config", "/etc/ngrok.yml"]
    volumes:
      - ./ngrok.yml:/etc/ngrok.yml
    ports:
      - "${NGROK_PORT}:${NGROK_PORT}"
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  kong-migrations:
    image: kong:2.8.5-alpine
    command: kong migrations bootstrap
    environment:
      - KONG_DATABASE=${KONG_DATABASE}
      - KONG_PG_HOST=${POSTGRES_HOST}
      - KONG_PG_PORT=${POSTGRES_PORT}
      - KONG_PG_USER=${POSTGRES_USERNAME}
      - KONG_PG_PASSWORD=${POSTGRES_PASSWORD}
      # - KONG_PG_DATABASE=${POSTGRES_DATABASE}
    depends_on:
      - postgres
    networks:
      - app-network
    profiles:
      - authentication

  kong:
    image: kong:2.8.5-alpine
    container_name: kong
    environment:
      - KONG_DATABASE=${KONG_DATABASE}
      - KONG_PG_HOST=${POSTGRES_HOST}
      - KONG_PG_PORT=${POSTGRES_PORT}
      - KONG_PG_USER=${POSTGRES_USERNAME}
      - KONG_PG_PASSWORD=${POSTGRES_PASSWORD}
      # - KONG_PG_DATABASE=${POSTGRES_DATABASE}
      - KONG_PROXY_ACCESS_LOG=${KONG_PROXY_ACCESS_LOG}
      - KONG_ADMIN_ACCESS_LOG=${KONG_ADMIN_ACCESS_LOG}
      - KONG_PROXY_ERROR_LOG=${KONG_PROXY_ERROR_LOG}
      - KONG_ADMIN_ERROR_LOG=${KONG_ADMIN_ERROR_LOG}
      - KONG_ADMIN_LISTEN=${KONG_ADMIN_LISTEN}
    ports:
      - "${KONG_PROXY_PORT}:${KONG_PROXY_PORT}"
      - "${KONG_PROXY_SSL_PORT}:${KONG_PROXY_SSL_PORT}"
      - "${KONG_ADMIN_PORT}:${KONG_ADMIN_PORT}"
      - "${KONG_ADMIN_SSL_PORT}:${KONG_ADMIN_SSL_PORT}"
    depends_on:
      - kong-migrations
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  rabbitmq:
    image: "rabbitmq:4.0.0-beta.3-management-alpine"
    container_name: rabbitmq
    environment:
      - RABBITMQ_USER=${RABBITMQ_USER}
      - RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD}
      - RABBITMQ_DEFAULT_VHOST=${RABBITMQ_VHOST}
    ports:
      - "${RABBITMQ_PORT}:${RABBITMQ_PORT}"
      - "${RABBITMQ_MANAGEMENT_PORT}:${RABBITMQ_MANAGEMENT_PORT}"
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  dynamodb:
    image: amazon/dynamodb-local:1.24.0
    container_name: dynamodb
    command: "-jar DynamoDBLocal.jar -port ${DYNAMODB_PORT} -sharedDb -dbPath /home/dynamodblocal/data"
    ports:
      - "${DYNAMODB_PORT}:${DYNAMODB_PORT}"
    volumes:
      - dynamodb_data:/home/dynamodblocal/data
    networks:
      - app-network
    restart: on-failure
    profiles:
      - authentication

  vault:
    image: vault:1.13.3
    container_name: vault
    ports:
      - "${VAULT_PORT}:${VAULT_PORT}"
    environment:
      VAULT_ADDR: http://localhost:8200
      VAULT_API_ADDR: http://localhost:8200
      VAULT_CLUSTER_ADDR: http://vault:8201
      VAULT_UI: "true"
    volumes:
      - ./vault-config.hcl:/vault/config/vault-config.hcl
      - vault_data:/vault/data
    command: vault server -config=/vault/config/vault-config.hcl
    depends_on:
      - consul
    networks:
      - app-network
    restart: on-failure
    cap_add:
      - IPC_LOCK
    profiles:
      - authentication

  localstack:
    image: localstack/localstack
    container_name: localstack
    ports:
      - "${AWS_EDGE_PORT}:${AWS_EDGE_PORT}"     # Puerto donde se exponen los servicios de AWS
      - "${AWS_WEB_UI_PORT}:${AWS_WEB_UI_PORT}" # Puerto para la interfaz web de LocalStack (opcional)
    environment:
      - SERVICES=${AWS_SERVICES}             # Lista de servicios de AWS que se van a emular
      - DEFAULT_REGION=${AWS_REGION} # Región predeterminada para AWS
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}         # Credenciales ficticias
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      - EDGE_PORT=${AWS_EDGE_PORT}           # Puerto principal para LocalStack
    volumes:
      - "./localstack:/var/lib/localstack" # Opcional: persistencia de datos en LocalStack
    networks:
      - app-network
    restart: on-failure
    profiles:
      - sg_auth 
      - sg_users
      - sg_mailing

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:
  pgadmin_data:
  cassandra_data:
  mysql_data:
  pyroscope_data:
  mongodb_data:
  dynamodb_data:
  vault_data:
