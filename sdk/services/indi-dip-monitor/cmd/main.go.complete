package main

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing/object"
	"gopkg.in/yaml.v2"
)

// Definición de la estructura del archivo monitor.yml
type LayerConfig struct {
	Layers struct {
		Domain         string `yaml:"domain"`
		Application    string `yaml:"application"`
		Infrastructure string `yaml:"infrastructure"`
	} `yaml:"layers"`
}

type Metric struct {
	MetricID  string     `json:"metric_id"`
	GitAuthor string     `json:"git_author"`
	Score     int        `json:"score"`
	Evidence  []Evidence `json:"evidence"`
}

type Evidence struct {
	File string `json:"file"`
	Line int    `json:"line"`
}

type fileImports struct {
	name  string
	path  string
	layer string
}

var packagesInfo []fileImports
var errors []string
var globalMetric = Metric{
	MetricID: "dependency_inversion",
	Score:    3,
	Evidence: []Evidence{},
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: go run main.go <repo_path>")
		return
	}

	repoPath := os.Args[1]

	// Cargar el archivo monitor.yml para las capas
	layerConfig, err := loadLayerConfig(filepath.Join(repoPath, "monitor.yml"))
	if err != nil {
		fmt.Printf("Error loading layer configuration: %v\n", err)
		return
	}

	repo, err := git.PlainOpen(repoPath)
	if err != nil {
		fmt.Printf("Error opening repository: %v\n", err)
		return
	}

	head, err := repo.Head()
	if err != nil {
		fmt.Printf("Error getting HEAD: %v\n", err)
		return
	}

	commit, err := repo.CommitObject(head.Hash())
	if err != nil {
		fmt.Printf("Error getting commit: %v\n", err)
		return
	}

	tree, err := commit.Tree()
	if err != nil {
		fmt.Printf("Error getting tree: %v\n", err)
		return
	}

	// Recorre todos los archivos y los clasifica
	err = filepath.Walk(repoPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && filepath.Ext(path) == ".go" {
			classifyFile(path, layerConfig, repoPath)
		}
		return nil
	})

	if err != nil {
		fmt.Printf("Error walking the path %v: %v\n", repoPath, err)
		return
	}

	printPackagesList(packagesInfo)

	// Validar las importaciones según las reglas
	for _, file := range packagesInfo {
		validateImports(file, layerConfig)
	}

	// Mostrar los errores encontrados
	printErrors()

	// Generar análisis de DIP
	metrics := analyzeCode(repo, tree, repoPath, []string{})
	jsonOutput, _ := json.MarshalIndent(metrics, "", "  ")
	fmt.Println(string(jsonOutput))
}

// Cargar el archivo monitor.yml
func loadLayerConfig(path string) (LayerConfig, error) {
	var config LayerConfig
	content, err := os.ReadFile(path)
	if err != nil {
		return config, err
	}
	err = yaml.Unmarshal(content, &config)
	return config, err
}

func classifyFile(filePath string, config LayerConfig, repoPath string) {
	absFilePath, _ := filepath.Abs(filePath)

	domainPath, _ := filepath.Abs(filepath.Join(repoPath, config.Layers.Domain))
	applicationPath, _ := filepath.Abs(filepath.Join(repoPath, config.Layers.Application))
	infrastructurePath, _ := filepath.Abs(filepath.Join(repoPath, config.Layers.Infrastructure))

	switch {
	case isSubPath(domainPath, absFilePath):
		pkgName, _ := getPackageName(filePath)
		addFileImport(pkgName, absFilePath, "domain")
	case isSubPath(applicationPath, absFilePath):
		pkgName, _ := getPackageName(filePath)
		addFileImport(pkgName, absFilePath, "application")
	case isSubPath(infrastructurePath, absFilePath):
		pkgName, _ := getPackageName(filePath)
		addFileImport(pkgName, absFilePath, "infrastructure")
	default:
		fmt.Printf("File: %s does not belong to any known layer\n", filePath)
	}
}

func isSubPath(basePath, targetPath string) bool {
	relPath, err := filepath.Rel(basePath, targetPath)
	if err != nil {
		return false
	}
	return !strings.HasPrefix(relPath, "..")
}

func getPackageName(filePath string) (string, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.PackageClauseOnly)
	if err != nil {
		return "", fmt.Errorf("error parsing file: %v", err)
	}
	if node.Name != nil {
		return node.Name.Name, nil
	}
	return "", fmt.Errorf("package name not found")
}

func addFileImport(name, path, layer string) {
	newImport := fileImports{
		name:  name,
		path:  path,
		layer: layer,
	}
	packagesInfo = append(packagesInfo, newImport)
}

func printPackagesList(packagesInfo []fileImports) {
	fmt.Println("Paquetes encontrados:")
	for _, imp := range packagesInfo {
		fmt.Printf("Nombre: %s, Path: %s, Capa: %s\n", imp.name, imp.path, imp.layer)
	}
}

func validateImports(file fileImports, config LayerConfig) {
	imports, err := getFileImports(file.path)
	if err != nil {
		fmt.Printf("Error processing file: %v\n", err)
		return
	}

	for _, imp := range imports {
		switch file.layer {
		case "domain":
			if !isAllowedImportInDomain(imp, config) {
				errors = append(errors, fmt.Sprintf("Error in file %s: invalid import %s in domain layer", file.path, imp))
			}
		case "application":
			if !isAllowedImportInApplication(imp, config, file.path) {
				errors = append(errors, fmt.Sprintf("Error in file %s: invalid import %s in application layer", file.path, imp))
			}
		}
	}
}

func isAllowedImportInDomain(importPath string, config LayerConfig) bool {
	if isStdLib(importPath) || strings.Contains(importPath, config.Layers.Domain) {
		return true
	}
	return false
}

func isAllowedImportInApplication(importPath string, config LayerConfig, filePath string) bool {
	if isStdLib(importPath) || strings.Contains(importPath, config.Layers.Domain) || strings.Contains(importPath, config.Layers.Application) {
		return true
	}
	if strings.Contains(importPath, config.Layers.Infrastructure) {
		if isInterfaceUsed(filePath, importPath) {
			return true
		}
	}
	return false
}

func isStdLib(importPath string) bool {
	return !strings.Contains(importPath, ".")
}

func getFileImports(filePath string) ([]string, error) {
	var imports []string
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ImportsOnly)
	if err != nil {
		return nil, fmt.Errorf("error parsing file: %v", err)
	}

	for _, imp := range node.Imports {
		imports = append(imports, strings.Trim(imp.Path.Value, "\""))
	}

	return imports, nil
}

func isInterfaceUsed(filePath, importPath string) bool {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.AllErrors)
	if err != nil {
		fmt.Printf("Error parsing file: %v\n", err)
		return false
	}

	interfaces := make(map[string]bool)
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			if _, ok := x.Type.(*ast.InterfaceType); ok {
				interfaces[x.Name.Name] = true
			}
		}
		return true
	})

	return len(interfaces) > 0
}

func printErrors() {
	fmt.Println("Errores encontrados:")
	for _, err := range errors {
		fmt.Println(err)
	}
}

// Función para analizar el código en busca de violaciones del DIP
func analyzeCode(repo *git.Repository, tree *object.Tree, repoPath string, filesToAnalyze []string) []Metric {
	var metrics []Metric
	dipMetric, err := analyzeDependencyInversion(repo, tree, repoPath, filesToAnalyze)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	metrics = append(metrics, dipMetric)
	return metrics
}

func analyzeDependencyInversion(repo *git.Repository, tree *object.Tree, repoPath string, filesToAnalyze []string) (Metric, error) {
	metric := globalMetric

	for _, filePath := range filesToAnalyze {
		content, err := os.ReadFile(filepath.Join(repoPath, filePath))
		if err != nil {
			return metric, fmt.Errorf("error reading file: %v", err)
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, filePath, content, parser.AllErrors)
		if err != nil {
			return metric, fmt.Errorf("error parsing file: %v", err)
		}

		ast.Inspect(node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.TypeSpec:
				if _, ok := x.Type.(*ast.InterfaceType); ok {
					// Aquí puedes agregar lógica para manejar las interfaces si es necesario
				}
			case *ast.CallExpr:
				// Aquí puedes agregar la lógica para detectar las llamadas a dependencias concretas
				metric.Evidence = append(metric.Evidence, Evidence{
					File: filePath,
					Line: fset.Position(x.Pos()).Line,
				})
			}
			return true
		})
	}

	// Ajustar el puntaje si hay evidencia de violaciones
	if len(metric.Evidence) > 0 {
		metric.Score = 2 // Si hay violaciones, ajusta el score
	} else {
		metric.Score = 3 // Si no hay violaciones, el sistema respeta el DIP
	}

	return metric, nil
}
