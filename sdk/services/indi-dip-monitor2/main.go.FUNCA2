package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v2"
)

// LayerConfig define la configuración de las capas a partir de un archivo YAML
type LayerConfig struct {
	Layers map[string][]string `yaml:"layers"`
}

// EntityInfo almacena información sobre las entidades encontradas (variables, structs, interfaces, etc.)
type EntityInfo struct {
	Name        string
	Type        string
	Position    int
	Category    string
	Kind        string // interface, struct, etc.
	IsInterface bool
	Layer       string
}

// FileImport almacena información sobre los archivos de código y sus entidades
type FileImport struct {
	Name     string
	Path     string
	Layer    string
	Entities []EntityInfo
}

// DependencyAnalyzer almacena los archivos procesados y posibles violaciones de dependencias
type DependencyAnalyzer struct {
	PackagesInfo         []FileImport
	DependencyViolations []string
}

// NewDependencyAnalyzer inicializa una nueva instancia del analizador de dependencias
func NewDependencyAnalyzer() *DependencyAnalyzer {
	return &DependencyAnalyzer{
		PackagesInfo:         []FileImport{},
		DependencyViolations: []string{},
	}
}

// AddFileImport agrega la información de un archivo procesado al analizador de dependencias
func (da *DependencyAnalyzer) AddFileImport(name, path, layer string, entities []EntityInfo) {
	da.PackagesInfo = append(da.PackagesInfo, FileImport{
		Name:     name,
		Path:     path,
		Layer:    layer,
		Entities: entities,
	})
}

// Cargar la configuración de capas desde un archivo monitor.yml
func loadLayerConfig(path string) (LayerConfig, error) {
	var config LayerConfig
	content, err := os.ReadFile(path)
	if err != nil {
		return config, err
	}
	err = yaml.Unmarshal(content, &config)
	return config, err
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: go run main.go <repo_path>")
		return
	}

	// Cargar la configuración de capas desde el archivo monitor.yml
	repoPath := os.Args[1]
	layerConfig, err := loadLayerConfig(filepath.Join(repoPath, "monitor.yml"))
	if err != nil {
		fmt.Printf("Error loading layer configuration: %v\n", err)
		return
	}

	// Crear el analizador de dependencias
	analyzer := NewDependencyAnalyzer()

	// Recorrer el directorio y clasificar los archivos .go
	err = filepath.Walk(repoPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() || filepath.Ext(path) != ".go" {
			return err
		}
		classifyFile(path, layerConfig, analyzer)
		return nil
	})

	if err != nil {
		fmt.Printf("Error walking the path %v: %v\n", repoPath, err)
		return
	}

	// Imprimir resultados del análisis
	printResults(analyzer)
}

// Clasificar un archivo según su capa y extraer las entidades que contiene
func classifyFile(filePath string, config LayerConfig, analyzer *DependencyAnalyzer) {
	entities, _ := listVariablesStructsParamsAndInterfaces(filePath, config)
	layer := determineLayer(filePath, config)
	pkgName, _ := getPackageName(filePath)
	analyzer.AddFileImport(pkgName, filePath, layer, entities)
}

// Determinar la capa de un archivo basado en su ruta
func determineLayer(filePath string, config LayerConfig) string {
	for layer, paths := range config.Layers {
		for _, path := range paths {
			if strings.Contains(filePath, path) {
				return layer
			}
		}
	}
	return "other"
}

// Obtener el nombre del paquete de un archivo Go
func getPackageName(filePath string) (string, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.PackageClauseOnly)
	if err != nil {
		return "", err
	}
	return node.Name.Name, nil
}

// Extraer las variables, structs, y parámetros de un archivo Go
func listVariablesStructsParamsAndInterfaces(filePath string, config LayerConfig) ([]EntityInfo, error) {
	cfg := &packages.Config{
		Mode: packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo,
		Dir:  filepath.Dir(filePath),
	}
	pkgs, err := packages.Load(cfg, "./...")
	if err != nil || len(pkgs) == 0 {
		return nil, err
	}

	var results []EntityInfo
	pkg := pkgs[0]
	file, err := getFileFromPackage(pkg, filePath)
	if err != nil {
		return nil, err
	}

	imports := extractImports(file)

	// Usar ast.Inspect para recorrer el AST y extraer entidades
	ast.Inspect(file, func(n ast.Node) bool {
		if genDecl, ok := n.(*ast.GenDecl); ok && genDecl.Tok == token.VAR {
			processVariables(genDecl, pkg, imports, config, &results)
		}
		if funcDecl, ok := n.(*ast.FuncDecl); ok {
			processFunctionParamsAndResults(funcDecl, pkg, imports, config, &results)
		}
		if typeDecl, ok := n.(*ast.TypeSpec); ok {
			processStructFields(typeDecl, pkg, imports, config, &results)
		}
		return true
	})

	return results, nil
}

// Obtener el archivo AST del paquete que corresponde al filePath
func getFileFromPackage(pkg *packages.Package, filePath string) (*ast.File, error) {
	for _, file := range pkg.Syntax {
		if pkg.Fset.Position(file.Pos()).Filename == filePath {
			return file, nil
		}
	}
	return nil, fmt.Errorf("file not found in package")
}

// Extraer las importaciones de un archivo Go
func extractImports(file *ast.File) map[string]string {
	imports := make(map[string]string)
	for _, i := range file.Imports {
		alias := ""
		if i.Name != nil {
			alias = i.Name.Name
		} else {
			parts := strings.Split(strings.Trim(i.Path.Value, "\""), "/")
			alias = parts[len(parts)-1]
		}
		imports[alias] = strings.Trim(i.Path.Value, "\"")
	}
	return imports
}

// Procesar las variables globales y locales y agregarlas a los resultados
func processVariables(decl *ast.GenDecl, pkg *packages.Package, imports map[string]string, config LayerConfig, results *[]EntityInfo) {
	for _, spec := range decl.Specs {
		if vspec, ok := spec.(*ast.ValueSpec); ok {
			for _, name := range vspec.Names {
				var varType string
				if vspec.Type != nil {
					varType = getTypeFromAST(vspec.Type, imports)
				} else {
					obj := pkg.TypesInfo.ObjectOf(name)
					varType = obj.Type().String()
				}

				// Verificar si es una variable global o local
				pos := pkg.Fset.Position(vspec.Pos())
				if isGlobalVariable(pos.Filename, pos.Line, pkg) {
					// Es una variable global
					layer := getLayerForType(varType, config)
					kind := getKindFromObj(pkg.TypesInfo.ObjectOf(name))
					*results = append(*results, EntityInfo{
						Name:        name.Name,
						Type:        varType,
						Position:    int(name.Pos()),
						Category:    "Global Variable",
						Kind:        kind,
						IsInterface: kind == "interface",
						Layer:       layer,
					})
				} else {
					// Es una variable local
					layer := getLayerForType(varType, config)
					kind := getKindFromObj(pkg.TypesInfo.ObjectOf(name))
					*results = append(*results, EntityInfo{
						Name:        name.Name,
						Type:        varType,
						Position:    int(name.Pos()),
						Category:    "Local Variable",
						Kind:        kind,
						IsInterface: kind == "interface",
						Layer:       layer,
					})
				}
			}
		}
	}
}

// Procesar los parámetros y resultados de las funciones y agregarlos a los resultados
func processFunctionParamsAndResults(funcDecl *ast.FuncDecl, pkg *packages.Package, imports map[string]string, config LayerConfig, results *[]EntityInfo) {
	if funcDecl.Type.Params != nil {
		for _, param := range funcDecl.Type.Params.List {
			paramType := getTypeFromAST(param.Type, imports)
			kind := getKindFromType(param.Type, pkg)
			layer := getLayerForType(paramType, config)
			for _, paramName := range param.Names {
				*results = append(*results, EntityInfo{
					Name:        paramName.Name,
					Type:        paramType,
					Position:    int(paramName.Pos()),
					Category:    "Function Parameter",
					Kind:        kind,
					IsInterface: kind == "interface",
					Layer:       layer,
				})
			}
		}
	}
	if funcDecl.Type.Results != nil {
		for _, result := range funcDecl.Type.Results.List {
			resultType := getTypeFromAST(result.Type, imports)
			kind := getKindFromType(result.Type, pkg)
			layer := getLayerForType(resultType, config)
			*results = append(*results, EntityInfo{
				Type:        resultType,
				Position:    int(result.Pos()),
				Category:    "Function Return Type",
				Kind:        kind,
				IsInterface: kind == "interface",
				Layer:       layer,
			})
		}
	}

	// Procesar variables locales dentro de la función
	ast.Inspect(funcDecl.Body, func(n ast.Node) bool {
		if assignStmt, ok := n.(*ast.AssignStmt); ok {
			for _, lhs := range assignStmt.Lhs {
				if ident, ok := lhs.(*ast.Ident); ok {
					obj := pkg.TypesInfo.ObjectOf(ident)
					if obj != nil {
						varType := obj.Type().String()
						layer := getLayerForType(varType, config)
						kind := getKindFromObj(obj)
						*results = append(*results, EntityInfo{
							Name:        ident.Name,
							Type:        varType,
							Position:    int(ident.Pos()),
							Category:    "Local Variable",
							Kind:        kind,
							IsInterface: kind == "interface",
							Layer:       layer,
						})
					}
				}
			}
		}
		return true
	})
}

// Obtener el tipo de una entidad a partir de un objeto types.Object
func getKindFromObj(obj types.Object) string {
	if obj == nil {
		return "unknown"
	}
	switch obj.Type().Underlying().(type) {
	case *types.Interface:
		return "interface"
	case *types.Struct:
		return "struct"
	}
	return "other"
}

// Función para convertir un AST a tipo Go
func getTypeFromAST(expr ast.Expr, imports map[string]string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		if pkgIdent, ok := t.X.(*ast.Ident); ok {
			return fmt.Sprintf("%s.%s", imports[pkgIdent.Name], t.Sel.Name)
		}
	case *ast.StarExpr:
		return "*" + getTypeFromAST(t.X, imports)
	case *ast.ArrayType:
		return "[]" + getTypeFromAST(t.Elt, imports)
	}
	return "unknown"
}

// Verificar si una variable es global (nivel del paquete)
func isGlobalVariable(filename string, line int, pkg *packages.Package) bool {
	// Aquí puedes agregar la lógica para verificar si la variable está al nivel del paquete.
	// Una idea es revisar si está fuera del rango de las funciones o métodos.
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				start := pkg.Fset.Position(funcDecl.Pos()).Line
				end := pkg.Fset.Position(funcDecl.End()).Line
				if line > start && line < end {
					return false // La variable está dentro de una función, no es global
				}
			}
		}
	}
	return true // Si no está dentro de ninguna función, es global
}

// Imprimir los resultados del análisis
func printResults(analyzer *DependencyAnalyzer) {
	for _, file := range analyzer.PackagesInfo {
		fmt.Printf("\nFile: %s\nLayer: %s\n", file.Path, file.Layer)
		for _, entity := range file.Entities {
			// Filtrar por capa y tipo
			if shouldDisplayEntity(file.Layer, entity) {
				fmt.Printf("  Category: %s, Name: %s, Type: %s, Kind: %s, Layer: %s, Line: %d\n",
					entity.Category, entity.Name, entity.Type, entity.Kind, entity.Layer, entity.Position)
			}
		}
	}
}

// Filtrar entidades por capa y tipo
func shouldDisplayEntity(fileLayer string, entity EntityInfo) bool {
	if fileLayer == "application" && (entity.Layer == "application" || entity.Layer == "domain") {
		return false
	}
	if entity.Kind == "interface" || isPrimitiveType(entity.Type) || isStandardLibraryType(entity.Type) {
		return false
	}
	return true
}

// Verificar si un tipo es primitivo
func isPrimitiveType(varType string) bool {
	primitives := []string{"int", "string", "bool", "float32", "float64", "byte", "rune", "complex64", "complex128"}
	for _, primitive := range primitives {
		if varType == primitive {
			return true
		}
	}
	return false
}

// Verificar si un tipo pertenece a la librería estándar
func isStandardLibraryType(varType string) bool {
	return !strings.Contains(varType, "/")
}

// Procesar los campos de structs y agregarlos a los resultados
func processStructFields(typeDecl *ast.TypeSpec, pkg *packages.Package, imports map[string]string, config LayerConfig, results *[]EntityInfo) {
	if structType, ok := typeDecl.Type.(*ast.StructType); ok {
		for _, field := range structType.Fields.List {
			fieldType := getTypeFromAST(field.Type, imports)
			kind := getKindFromType(field.Type, pkg)
			layer := getLayerForType(fieldType, config)
			for _, fieldName := range field.Names {
				*results = append(*results, EntityInfo{
					Name:        fieldName.Name,
					Type:        fieldType,
					Position:    int(field.Pos()),
					Category:    "Struct Field",
					Kind:        kind,
					IsInterface: kind == "interface",
					Layer:       layer,
				})
			}
		}
	}
}

// Determinar la capa de un tipo basado en su nombre
func getLayerForType(typeName string, config LayerConfig) string {
	for layer, paths := range config.Layers {
		for _, path := range paths {
			if strings.Contains(typeName, path) {
				return layer
			}
		}
	}
	return "other"
}

// Obtener el tipo de una entidad a partir de un tipo AST
func getKindFromType(expr ast.Expr, pkg *packages.Package) string {
	if typ, ok := pkg.TypesInfo.Types[expr]; ok {
		switch typ.Type.Underlying().(type) {
		case *types.Interface:
			return "interface"
		case *types.Struct:
			return "struct"
		}
	}
	return "other"
}
