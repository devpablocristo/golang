package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v2"
)

type LayerConfig struct {
	Layers map[string][]string `yaml:"layers"`
}

type TypeInfo struct {
	PackageName string
	TypeName    string
	TypeKind    string // struct, interface, etc.
	Layer       string // Capa a la que pertenece (domain, application, infrastructure, other)
}

type FieldInfo struct {
	FieldName   string
	FieldType   string
	PackageName string
	Layer       string
}

type VariableInfo struct {
	VarName     string
	PackageName string
	TypeName    string
	Layer       string
}

type FunctionInfo struct {
	FuncName    string
	PackageName string
	Params      []VariableInfo // Parámetros de entrada
	ReturnTypes []VariableInfo // Parámetros de salida
	Layer       string
}

type FileTypeInfo struct {
	FilePath   string
	TypesInfo  []TypeInfo
	FieldsInfo []FieldInfo
	VarsInfo   []VariableInfo
	FuncsInfo  []FunctionInfo
}

func main() {
	// Ruta del repositorio a analizar
	repoPath := "/home/pablo/Projects/Pablo/github.com/devpablocristo/meli/monitor-projects/regular"

	// Leer el archivo monitor.yml desde el repositorio
	configFile := filepath.Join(repoPath, "monitor.yml")
	layerConfig, err := loadConfig(configFile)
	if err != nil {
		fmt.Println("Error cargando el archivo monitor.yml:", err)
		return
	}

	// Analizar todos los archivos .go en el repositorio
	results, err := analyzeRepo(repoPath, layerConfig)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	// Imprimir resultados por archivo
	for _, fileInfo := range results {
		fmt.Printf("Archivo: %s\n", fileInfo.FilePath)
		for _, typeInfo := range fileInfo.TypesInfo {
			fmt.Printf("\tPackage: %s, Type: %s, Kind: %s, Layer: %s\n", typeInfo.PackageName, typeInfo.TypeName, typeInfo.TypeKind, typeInfo.Layer)
		}
		for _, fieldInfo := range fileInfo.FieldsInfo {
			fmt.Printf("\tField: %s, Type: %s, Layer: %s\n", fieldInfo.FieldName, fieldInfo.FieldType, fieldInfo.Layer)
		}
		for _, varInfo := range fileInfo.VarsInfo {
			fmt.Printf("\tVariable: %s, Package: %s, Type: %s, Layer: %s\n", varInfo.VarName, varInfo.PackageName, varInfo.TypeName, varInfo.Layer)
		}
		for _, funcInfo := range fileInfo.FuncsInfo {
			fmt.Printf("\tFunction: %s, Package: %s, Layer: %s\n", funcInfo.FuncName, funcInfo.PackageName, funcInfo.Layer)
			for _, param := range funcInfo.Params {
				fmt.Printf("\t\tParam: %s, Type: %s, Layer: %s\n", param.VarName, param.TypeName, param.Layer)
			}
			for _, ret := range funcInfo.ReturnTypes {
				fmt.Printf("\t\tReturn: %s, Type: %s, Layer: %s\n", ret.VarName, ret.TypeName, ret.Layer)
			}
		}
	}
}

func loadConfig(configFile string) (*LayerConfig, error) {
	config := &LayerConfig{}
	data, err := os.ReadFile(configFile)
	if err != nil {
		return nil, err
	}
	err = yaml.Unmarshal(data, config)
	if err != nil {
		return nil, err
	}
	return config, nil
}

func analyzeRepo(repoPath string, layerConfig *LayerConfig) ([]FileTypeInfo, error) {
	var results []FileTypeInfo

	// Recorrer el directorio del repositorio para encontrar todos los archivos .go
	err := filepath.WalkDir(repoPath, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Solo procesar archivos .go
		if !d.IsDir() && strings.HasSuffix(path, ".go") {
			// Obtener los tipos y variables definidos en el archivo
			typesInfo, fieldsInfo, varsInfo, funcsInfo, err := analyzeFile(path, layerConfig)
			if err != nil {
				fmt.Println("Error procesando archivo:", path, "Error:", err)
				return nil // Continuar con el siguiente archivo
			}

			// Agregar los resultados de este archivo
			results = append(results, FileTypeInfo{
				FilePath:   path,
				TypesInfo:  typesInfo,
				FieldsInfo: fieldsInfo,
				VarsInfo:   varsInfo,
				FuncsInfo:  funcsInfo,
			})
		}
		return nil
	})

	return results, err
}

// Nueva implementación que utiliza packages.Load para obtener información detallada de las variables, tipos, funciones y campos de structs
func analyzeFile(filePath string, layerConfig *LayerConfig) ([]TypeInfo, []FieldInfo, []VariableInfo, []FunctionInfo, error) {
	var typesInfo []TypeInfo
	var fieldsInfo []FieldInfo
	var varsInfo []VariableInfo
	var funcsInfo []FunctionInfo

	cfg := &packages.Config{
		Mode: packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo,
		Dir:  filepath.Dir(filePath),
	}
	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		return nil, nil, nil, nil, fmt.Errorf("failed to load package: %w", err)
	}

	if len(pkgs) == 0 {
		return nil, nil, nil, nil, fmt.Errorf("no packages found")
	}

	var pkg *packages.Package
	var file *ast.File
	for _, p := range pkgs {
		for _, f := range p.Syntax {
			if pkgs[0].Fset.Position(f.Pos()).Filename == filePath {
				pkg = p
				file = f
				break
			}
		}
	}

	if file == nil {
		return nil, nil, nil, nil, fmt.Errorf("file not found in package")
	}

	imports := make(map[string]string)
	for _, i := range file.Imports {
		importPath := strings.Trim(i.Path.Value, "\"")
		alias := ""
		if i.Name != nil {
			alias = i.Name.Name
		} else {
			parts := strings.Split(importPath, "/")
			alias = parts[len(parts)-1]
		}
		imports[alias] = importPath
	}

	ast.Inspect(file, func(n ast.Node) bool {
		// Análisis de variables globales y locales
		if decl, ok := n.(*ast.GenDecl); ok && decl.Tok == token.VAR {
			for _, spec := range decl.Specs {
				if vspec, ok := spec.(*ast.ValueSpec); ok {
					for _, name := range vspec.Names {
						var varType string
						if vspec.Type != nil {
							varType = getTypeFromAST(vspec.Type, imports)
						} else {
							obj := pkg.TypesInfo.ObjectOf(name)
							varType = obj.Type().String()
						}
						layer := getLayerForType(varType, layerConfig)
						varsInfo = append(varsInfo, VariableInfo{
							VarName:     name.Name,
							PackageName: pkg.PkgPath,
							TypeName:    varType,
							Layer:       layer,
						})
					}
				}
			}
		}

		// Análisis de tipos definidos
		if typeDecl, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := typeDecl.Type.(*ast.StructType); ok {
				typesInfo = append(typesInfo, TypeInfo{
					PackageName: pkg.PkgPath,
					TypeName:    typeDecl.Name.Name,
					TypeKind:    "struct",
					Layer:       getLayerForFile(filePath, *layerConfig),
				})

				// Análisis de los campos dentro de la estructura
				for _, field := range structType.Fields.List {
					fieldType := getTypeFromAST(field.Type, imports)
					for _, fieldName := range field.Names {
						layer := getLayerForType(fieldType, layerConfig)
						fieldsInfo = append(fieldsInfo, FieldInfo{
							FieldName:   fieldName.Name,
							FieldType:   fieldType,
							PackageName: pkg.PkgPath,
							Layer:       layer,
						})
					}
				}
			}
		}

		// Análisis de funciones
		if funcDecl, ok := n.(*ast.FuncDecl); ok {
			var funcInfo FunctionInfo
			funcInfo.FuncName = funcDecl.Name.Name
			funcInfo.PackageName = pkg.PkgPath
			funcInfo.Layer = getLayerForFile(filePath, *layerConfig)

			// Parámetros de entrada
			if funcDecl.Type.Params != nil {
				for _, param := range funcDecl.Type.Params.List {
					paramType := getTypeFromAST(param.Type, imports)
					for _, paramName := range param.Names {
						funcInfo.Params = append(funcInfo.Params, VariableInfo{
							VarName:     paramName.Name,
							PackageName: pkg.PkgPath,
							TypeName:    paramType,
							Layer:       getLayerForType(paramType, layerConfig),
						})
					}
				}
			}

			// Tipos de retorno
			if funcDecl.Type.Results != nil {
				for _, result := range funcDecl.Type.Results.List {
					resultType := getTypeFromAST(result.Type, imports)
					funcInfo.ReturnTypes = append(funcInfo.ReturnTypes, VariableInfo{
						VarName:     "", // Los tipos de retorno no tienen nombre
						PackageName: pkg.PkgPath,
						TypeName:    resultType,
						Layer:       getLayerForType(resultType, layerConfig),
					})
				}
			}

			funcsInfo = append(funcsInfo, funcInfo)
		}

		return true
	})

	return typesInfo, fieldsInfo, varsInfo, funcsInfo, nil
}

// getTypeFromAST analiza el AST y devuelve el tipo de una variable o campo de struct
func getTypeFromAST(expr ast.Expr, imports map[string]string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		if pkgIdent, ok := t.X.(*ast.Ident); ok {
			pkgAlias := pkgIdent.Name
			if pkgPath, ok := imports[pkgAlias]; ok {
				return fmt.Sprintf("%s.%s", pkgPath, t.Sel.Name)
			}
			return fmt.Sprintf("%s.%s", pkgAlias, t.Sel.Name)
		}
	case *ast.StarExpr:
		// Manejar tipos punteros (e.g., *Type)
		return "*" + getTypeFromAST(t.X, imports)
	case *ast.ArrayType:
		// Manejar tipos de arrays (e.g., []Type)
		return "[]" + getTypeFromAST(t.Elt, imports)
	}
	return "unknown"
}

// getLayerForType busca el layer basado en el tipo de la variable o campo
func getLayerForType(typeName string, layerConfig *LayerConfig) string {
	for layer, paths := range layerConfig.Layers {
		for _, path := range paths {
			if strings.Contains(typeName, path) {
				return layer
			}
		}
	}
	return "other" // Si no coincide con ninguna capa, devolver "other"
}

// getLayerForFile determina la capa de un archivo según su ruta
func getLayerForFile(filePath string, layerConfig LayerConfig) string {
	for layer, paths := range layerConfig.Layers {
		for _, path := range paths {
			if strings.Contains(filePath, path) {
				return layer
			}
		}
	}
	return "other" // Si no coincide con ninguna capa, devolver "other"
}
